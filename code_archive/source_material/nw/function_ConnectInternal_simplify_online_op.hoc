//By Pirate Henry 2011 and modified by Feng and Keyang 2014/* obfunc LoadMatrix() { local nrow,ncol localobj mat,datafile		nrow = $2	ncol = $3	datafile = new File()	datafile.ropen($s1)	mat = new Matrix()	mat.scanf(datafile,nrow,ncol)	//print mat.nrow, mat.ncol	datafile.close()	return mat}*//*objref InternalSynMatrix,InternalThrMatrix,InternalWgtMatrix,InternalDelMatrixInternalSynMatrix = new Matrix()//InternalThrMatrix = new Matrix()InternalWgtMatrix = new Matrix()InternalDelMatrix = new Matrix()InternalSynMatrix = LoadMatrix(FileLocationStr_InternalSynConns,TotalCellNum,TotalCellNum)//InternalThrMatrix = LoadMatrix(FileLocationStr_InternalThrConns,TotalCellNum,TotalCellNum)InternalWgtMatrix = LoadMatrix(FileLocationStr_InternalWgtConns,TotalCellNum,TotalCellNum)InternalDelMatrix = LoadMatrix(FileLocationStr_InternalDelConns,TotalCellNum,TotalCellNum)*/objref InternalsynList,InternalncList,fih,rdm,rc_E2E,rc_I2I,rc_I2E,rc_E2I,rc_P2SOM,rc_SOM2P,rc_SOM2ITN,rc_ITN2SOMInternalsynList = new List()InternalncList = new List()//rdm = new Random()maxdelay=2.425//4.5 ////define maximum delay,msmindelay=0.8//0.8 ////define minmum delay,msmaxdis=2.425  /// mm sqrt((1.4)^2+(1.4)^2+(1.4)^2)proc ConnectInternal() { local i,j,cellgid,inputid,synid,thr,wgt,del localobj vx      for i = 0,TotalCellNum-1 {      cellgid=i      if(!pc.gid_exists(cellgid)) { continue }        ind_start=1+3*cellgid        ind_stop=2+3*cellgid             vx=syn_connect.at(syn_ind.x[ind_start],syn_ind.x[ind_stop])  ///to get all pre syns ID         for jj=0,vx.size()-1   {              inputid=vx.x[jj]            if (cellgid<CellNum_p&&inputid<CellNum_p) {               synid = 1    ///for CP2CP connections               rc_E2E = new Random(cellgid*TotalCellNum+inputid+1)               wgt = rc_E2E.lognormal(0.5,0.05)//(1,0.05)//(2,1)               del_fluc = rc_E2E.uniform(-0.1,0.1)                                          } else if (cellgid<CellNum_p&&inputid>=CellNum_p&&inputid<CellNum_p+CellNum_interneuron) {               synid = 3      ///for PV2CP connections                rc_I2E = new Random(cellgid*TotalCellNum+inputid+1)               wgt = rc_I2E.lognormal(12,2)               del_fluc = rc_I2E.uniform(-0.1,0.1)                                           } else if (cellgid>=CellNum_p&&cellgid<CellNum_p+CellNum_interneuron&&inputid<CellNum_p) {               synid = 2      ///for CP2PV connections                rc_E2I = new Random(cellgid*TotalCellNum+inputid+1)               wgt = rc_E2I.lognormal(2,1)//(7,2)               del_fluc = rc_E2I.uniform(-0.1,0.1)                                               } else if (cellgid>=CellNum_p&&cellgid<CellNum_p+CellNum_interneuron&&inputid>=CellNum_p&&inputid<CellNum_p+CellNum_interneuron) {               synid = 4  ///for PV2PV connections                rc_I2I = new Random(cellgid*TotalCellNum+inputid+1)               wgt = rc_I2I.lognormal(10,5)//(20,10)               del_fluc = rc_I2I.uniform(-0.1,0.1)             } else if (cellgid>=CellNum_p+CellNum_interneuron&&inputid<CellNum_p) {               synid = 5  ///for CP2SOM connections                rc_P2SOM = new Random(cellgid*TotalCellNum+inputid+1)               wgt = rc_P2SOM.lognormal(0.05,0.002)//(0.02,0.0002)//(7,2)               del_fluc = rc_P2SOM.uniform(-0.1,0.1)             } else if (cellgid<CellNum_p&&inputid>=CellNum_p+CellNum_interneuron) {               synid = 6  ///for SOM2CP connections                rc_SOM2P = new Random(cellgid*TotalCellNum+inputid+1)               wgt = rc_SOM2P.lognormal(0.5,0.02)//(12,2)               del_fluc = rc_SOM2P.uniform(-0.1,0.1)                            } else if (cellgid>=CellNum_p&&cellgid<CellNum_p+CellNum_interneuron&&inputid>=CellNum_p+CellNum_interneuron) {               synid = 7  ///for SOM2ITN connections                rc_SOM2ITN = new Random(cellgid*TotalCellNum+inputid+1)               wgt = rc_SOM2ITN.lognormal(1,0.5)//(20,2)               del_fluc = rc_SOM2ITN.uniform(-0.1,0.1)                            } else if (cellgid>=CellNum_p+CellNum_interneuron&&inputid>=CellNum_p&&inputid<CellNum_p+CellNum_interneuron) {               synid = 8  ///for ITN2SOM connections                rc_ITN2SOM = new Random(cellgid*TotalCellNum+inputid+1)               wgt = rc_ITN2SOM.lognormal(1,0.5)//(2,1)//(12,2)               del_fluc = rc_ITN2SOM.uniform(-0.1,0.1)             }                          dis=sqrt((Location.x[inputid][0]-Location.x[cellgid][0])^2+(Location.x[inputid][1]-Location.x[cellgid][1])^2+(Location.x[inputid][2]-Location.x[cellgid][2])^2)			 del=(dis/maxdis)*maxdelay+mindelay+del_fluc+dt             ConnectTwoCells(inputid,cellgid,synid,wgt,del,InternalsynList,InternalncList)}}	 {pc.barrier()}     saveM.close()}/*proc ConnectInternal_EE() { local i,j,cellgid,inputid,synid,thr,wgt,del	{pc.barrier()}	for j = 0,PP_size_matrix.x[0][1]-1 {		//cellgid = CellList.o(j).mygid		for i = 0,CellNum_p-1 {        	cellgid = E2E_syn_matrix.x[i][j]                  if (cellgid>=0) {                        if(!pc.gid_exists(cellgid)) { continue }			//Rdm_D = rdm.discunif(1, 5)						// random number generator for different delay            inputid = i            {rc_E2E = new Random(cellgid*TotalCellNum+inputid+1)}			//synid = InternalSynMatrix.x[inputid][cellgid]            synid = 1			//print(synid)			if (synid != 0) {				//print(synid)				//printf("The cell #%d gets input from Cell #%d with synid #%d!\n",cellgid,inputid,synid)				//thr = InternalThrMatrix.x[inputid][cellgid]				//wgt = E2E_wgt_matrix.x[inputid][j]				//del = E2E_del_matrix.x[inputid][j]                  wgt = rc_E2E.lognormal(2,1)                  del_fluc = rc_E2E.uniform(-0.1,0.1)                  dis=sqrt((Location.x[inputid][0]-Location.x[cellgid][0])^2+(Location.x[inputid][1]-Location.x[cellgid][1])^2+(Location.x[inputid][2]-Location.x[cellgid][2])^2)				  del=(dis/maxdis)*maxdelay+mindelay+del_fluc+dt                //printf("%f,%f,%f\n",thr,wgt,del)				//if (del<dt) {				//	print del				//}               				ConnectTwoCells(inputid,cellgid,synid,wgt,del,InternalsynList,InternalncList)				//ConnectTwoCells(inputid,cellgid,synid,Rdm_D,InternalsynList,InternalncList)			}		}              }          }       	{pc.barrier()}     saveM.close()   }   proc ConnectInternal_PI_reversed() { local i,j,cellgid,inputid,synid,thr,wgt,del	{pc.barrier()}	for j = 0,CellNum_interneuron-1 { 		cellgid = j+CellNum_p		for i = 0,PI_size_matrix.x[0][1]-1 {        	inputid = P2I_syn_matrix_reversed.x[j][i]               if (inputid>=0) {                        if(!pc.gid_exists(cellgid)) { continue }			//Rdm_D = rdm.discunif(1, 5)						// random number generator for different delay			rc_E2I = new Random(cellgid*TotalCellNum+inputid+1) 			//synid = InternalSynMatrix.x[inputid][cellgid]            synid = 2			//print(synid)			if (synid != 0) {				//print(synid)				//printf("The cell #%d gets input from Cell #%d with synid #%d!\n",cellgid,inputid,synid)				//thr = InternalThrMatrix.x[inputid][cellgid]				//wgt = P2I_wgt_matrix.x[j][i]				//del = P2I_del_matrix.x[j][i]                  wgt = rc_E2I.lognormal(7,2)                  del_fluc = rc_E2I.uniform(-0.1,0.1)                  dis=sqrt((Location.x[inputid][0]-Location.x[cellgid][0])^2+(Location.x[inputid][1]-Location.x[cellgid][1])^2+(Location.x[inputid][2]-Location.x[cellgid][2])^2)				  del=(dis/maxdis)*maxdelay+mindelay+del_fluc+dt				//printf("%f,%f,%f\n",thr,wgt,del)				//if (del<dt) {				//	print del				//}               				ConnectTwoCells(inputid,cellgid,synid,wgt,del,InternalsynList,InternalncList)				//ConnectTwoCells(inputid,cellgid,synid,Rdm_D,InternalsynList,InternalncList)			}		}              }          }       	{pc.barrier()}     saveM.close()   }   proc ConnectInternal_IP() { local i,j,cellgid,inputid,synid,thr,wgt,del	{pc.barrier()}	for j = 0,IP_size_matrix.x[0][1]-1 {		//cellgid = CellList.o(j).mygid		for i = 0,CellNum_interneuron-1 {        	cellgid = I2P_syn_matrix.x[i][j]                  if (cellgid>=0) {                        if(!pc.gid_exists(cellgid)) { continue }			//Rdm_D = rdm.discunif(1, 5)						// random number generator for different delay			inputid = i+CellNum_p            rc_I2E = new Random(cellgid*TotalCellNum+inputid+1) 			//synid = InternalSynMatrix.x[inputid][cellgid]            synid = 3			//print(synid)			if (synid != 0) {				//print(synid)				//printf("The cell #%d gets input from Cell #%d with synid #%d!\n",cellgid,inputid,synid)				//thr = InternalThrMatrix.x[inputid][cellgid]                  wgt = rc_I2E.lognormal(12,2)                  del_fluc = rc_I2E.uniform(-0.1,0.1)                  dis=sqrt((Location.x[inputid][0]-Location.x[cellgid][0])^2+(Location.x[inputid][1]-Location.x[cellgid][1])^2+(Location.x[inputid][2]-Location.x[cellgid][2])^2)				  del=(dis/maxdis)*maxdelay+mindelay+del_fluc+dt				//printf("%f,%f,%f\n",thr,wgt,del)				//if (del<dt) {				//	print del				//}               				ConnectTwoCells(inputid,cellgid,synid,wgt,del,InternalsynList,InternalncList)				//ConnectTwoCells(inputid,cellgid,synid,Rdm_D,InternalsynList,InternalncList)			}		}              }          }       	{pc.barrier()}     saveM.close()   }                  proc ConnectInternal_II() { local i,j,cellgid,inputid,synid,thr,wgt,del	{pc.barrier()}	for j = 0,II_size_matrix.x[0][1]-1 {		//cellgid = CellList.o(j).mygid		for i = 0,CellNum_interneuron-1 {        	cellgid = I2I_syn_matrix.x[i][j]                  if (cellgid>=0) {                        if(!pc.gid_exists(cellgid)) { continue }			//Rdm_D = rdm.discunif(1, 5)						// random number generator for different delay			inputid = i+CellNum_p            rc_I2I = new Random(cellgid*TotalCellNum+inputid+1) 			//synid = InternalSynMatrix.x[inputid][cellgid]            synid = 4			//print(synid)			if (synid != 0) {				//print(synid)				//printf("The cell #%d gets input from Cell #%d with synid #%d!\n",cellgid,inputid,synid)				//thr = InternalThrMatrix.x[inputid][cellgid]                  wgt = rc_I2I.lognormal(20,10)                  del_fluc = rc_I2I.uniform(-0.1,0.1)                  dis=sqrt((Location.x[inputid][0]-Location.x[cellgid][0])^2+(Location.x[inputid][1]-Location.x[cellgid][1])^2+(Location.x[inputid][2]-Location.x[cellgid][2])^2)				  del=(dis/maxdis)*maxdelay+mindelay+del_fluc+dt                  				//printf("%f,%f,%f\n",thr,wgt,del)				//if (del<dt) {				//	print del				//}               				ConnectTwoCells(inputid,cellgid,synid,wgt,del,InternalsynList,InternalncList)				//ConnectTwoCells(inputid,cellgid,synid,Rdm_D,InternalsynList,InternalncList)			}		}              }          }       	{pc.barrier()}     saveM.close()   }*/